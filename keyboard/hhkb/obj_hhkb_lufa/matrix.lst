   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_rows,"ax",@progbits
  11               	.global	matrix_rows
  13               	matrix_rows:
  14               	.LFB111:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2011 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <util/delay.h>
  24:matrix.c      **** #include "print.h"
  25:matrix.c      **** #include "debug.h"
  26:matrix.c      **** #include "util.h"
  27:matrix.c      **** #include "timer.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** #include "hhkb_avr.h"
  30:matrix.c      **** #include <avr/wdt.h>
  31:matrix.c      **** #include "suspend.h"
  32:matrix.c      **** #include "lufa.h"
  33:matrix.c      **** 
  34:matrix.c      **** 
  35:matrix.c      **** // matrix power saving
  36:matrix.c      **** #define MATRIX_POWER_SAVE       10000
  37:matrix.c      **** static uint32_t matrix_last_modified = 0;
  38:matrix.c      **** 
  39:matrix.c      **** // matrix state buffer(1:on, 0:off)
  40:matrix.c      **** static matrix_row_t *matrix;
  41:matrix.c      **** static matrix_row_t *matrix_prev;
  42:matrix.c      **** static matrix_row_t _matrix0[MATRIX_ROWS];
  43:matrix.c      **** static matrix_row_t _matrix1[MATRIX_ROWS];
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  16               		.loc 1 48 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  22               		.loc 1 50 0
  23 0000 88E0      		ldi r24,lo8(8)
  24 0002 0895      		ret
  25               		.cfi_endproc
  26               	.LFE111:
  28               		.section	.text.matrix_cols,"ax",@progbits
  29               	.global	matrix_cols
  31               	matrix_cols:
  32               	.LFB112:
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  33               		.loc 1 54 0
  34               		.cfi_startproc
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 0 */
  38               	.L__stack_usage = 0
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  39               		.loc 1 56 0
  40 0000 88E0      		ldi r24,lo8(8)
  41 0002 0895      		ret
  42               		.cfi_endproc
  43               	.LFE112:
  45               		.section	.text.matrix_init,"ax",@progbits
  46               	.global	matrix_init
  48               	matrix_init:
  49               	.LFB113:
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  50               		.loc 1 59 0
  51               		.cfi_startproc
  52               	/* prologue: function */
  53               	/* frame size = 0 */
  54               	/* stack size = 0 */
  55               	.L__stack_usage = 0
  56               	.LBB44:
  57               	.LBB45:
  58               		.file 2 "hhkb_avr.h"
   1:hhkb_avr.h    **** #ifndef HHKB_AVR_H
   2:hhkb_avr.h    **** #define HHKB_AVR_H
   3:hhkb_avr.h    **** 
   4:hhkb_avr.h    **** #include <stdint.h>
   5:hhkb_avr.h    **** #include <stdbool.h>
   6:hhkb_avr.h    **** #include <avr/io.h>
   7:hhkb_avr.h    **** #include <avr/interrupt.h>
   8:hhkb_avr.h    **** #include <util/delay.h>
   9:hhkb_avr.h    **** 
  10:hhkb_avr.h    **** 
  11:hhkb_avr.h    **** // Timer resolution check
  12:hhkb_avr.h    **** #if (1000000/TIMER_RAW_FREQ > 20)
  13:hhkb_avr.h    **** #   error "Timer resolution(>20us) is not enough for HHKB matrix scan tweak on V-USB."
  14:hhkb_avr.h    **** #endif
  15:hhkb_avr.h    **** 
  16:hhkb_avr.h    **** 
  17:hhkb_avr.h    **** /*
  18:hhkb_avr.h    ****  * HHKB Matrix I/O
  19:hhkb_avr.h    ****  *
  20:hhkb_avr.h    ****  * row:     HC4051[A,B,C]  selects scan row0-7
  21:hhkb_avr.h    ****  * row-ext: [En0,En1] row extention for JP
  22:hhkb_avr.h    ****  * col:     LS145[A,B,C,D] selects scan col0-7 and enable(D)
  23:hhkb_avr.h    ****  * key:     on: 0/off: 1
  24:hhkb_avr.h    ****  * prev:    hysteresis control: assert(1) when previous key state is on
  25:hhkb_avr.h    ****  */
  26:hhkb_avr.h    **** 
  27:hhkb_avr.h    **** 
  28:hhkb_avr.h    **** #if defined(__AVR_ATmega32U4__)
  29:hhkb_avr.h    **** /*
  30:hhkb_avr.h    ****  * For TMK HHKB alt controller(ATMega32U4)
  31:hhkb_avr.h    ****  *
  32:hhkb_avr.h    ****  * row:     PB0-2
  33:hhkb_avr.h    ****  * col:     PB3-5,6
  34:hhkb_avr.h    ****  * key:     PD7(pull-uped)
  35:hhkb_avr.h    ****  * prev:    PB7
  36:hhkb_avr.h    ****  * power:   PD4(L:off/H:on)
  37:hhkb_avr.h    ****  * row-ext: PC6,7 for HHKB JP(active low)
  38:hhkb_avr.h    ****  */
  39:hhkb_avr.h    **** static inline void KEY_ENABLE(void) { (PORTB &= ~(1<<6)); }
  40:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
  41:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PINF & (1<<0)); }
  42:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTF |=  (1<<1)); }
  43:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTF &= ~(1<<1)); }
  44:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
  45:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {
  46:hhkb_avr.h    ****     DDRB = 0xFF; PORTB = 0x40;          // change pins output
  47:hhkb_avr.h    ****  //   DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  48:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  49:hhkb_avr.h    ****     _delay_ms(5);                       // wait for powering up
  50:hhkb_avr.h    **** }
  51:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {
  52:hhkb_avr.h    ****     /* input with pull-up consumes less than without it when pin is open. */
  53:hhkb_avr.h    ****     DDRB = 0x00; PORTB = 0xFF;          // change pins input with pull-up
  54:hhkb_avr.h    ****  //   DDRD |= (1<<4); PORTD &= ~(1<<4);   // MOS FET switch off
  55:hhkb_avr.h    **** }
  56:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return PORTD & (1<<4); }
  57:hhkb_avr.h    **** #else
  58:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {}
  59:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {}
  60:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return true; }
  61:hhkb_avr.h    **** #endif
  62:hhkb_avr.h    **** static inline void KEY_INIT(void)
  63:hhkb_avr.h    **** {
  64:hhkb_avr.h    ****     /* row,col,prev: output */
  65:hhkb_avr.h    ****     DDRB  = 0xFF;
  59               		.loc 2 65 0
  60 0000 8FEF      		ldi r24,lo8(-1)
  61 0002 84B9      		out 0x4,r24
  66:hhkb_avr.h    ****     PORTB = 0x40;   // unable
  62               		.loc 2 66 0
  63 0004 80E4      		ldi r24,lo8(64)
  64 0006 85B9      		out 0x5,r24
  67:hhkb_avr.h    ****     DDRF |= (1<<1);
  65               		.loc 2 67 0
  66 0008 819A      		sbi 0x10,1
  68:hhkb_avr.h    ****     DDRF &= ~(1<<0);
  67               		.loc 2 68 0
  68 000a 8098      		cbi 0x10,0
  69:hhkb_avr.h    ****     PORTF |= (1<<0);
  69               		.loc 2 69 0
  70 000c 889A      		sbi 0x11,0
  71               	.LBB46:
  72               	.LBB47:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PINF & (1<<0)); }
  73               		.loc 2 40 0
  74 000e 2E9A      		sbi 0x5,6
  75               	.LBE47:
  76               	.LBE46:
  77               	.LBB48:
  78               	.LBB49:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
  79               		.loc 2 43 0
  80 0010 8998      		cbi 0x11,1
  81               	.LVL0:
  82 0012 E0E0      		ldi r30,lo8(_matrix0)
  83 0014 F0E0      		ldi r31,hi8(_matrix0)
  84               	.LVL1:
  85               	.L5:
  86               	.LBE49:
  87               	.LBE48:
  88               	.LBE45:
  89               	.LBE44:
  90               	.LBB50:
  60:matrix.c      **** #ifdef DEBUG
  61:matrix.c      ****     debug_enable = true;
  62:matrix.c      ****     debug_keyboard = true;
  63:matrix.c      **** #endif
  64:matrix.c      **** 
  65:matrix.c      ****     KEY_INIT();
  66:matrix.c      **** 
  67:matrix.c      ****     // initialize matrix state: all keys off
  68:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix0[i] = 0x00;
  91               		.loc 1 68 0 discriminator 2
  92 0016 1192      		st Z+,__zero_reg__
  93               	.LVL2:
  94 0018 80E0      		ldi r24,hi8(_matrix0+8)
  95 001a E030      		cpi r30,lo8(_matrix0+8)
  96 001c F807      		cpc r31,r24
  97 001e 01F4      		brne .L5
  98 0020 E0E0      		ldi r30,lo8(_matrix1)
  99 0022 F0E0      		ldi r31,hi8(_matrix1)
 100               	.LVL3:
 101               	.L7:
 102               	.LBE50:
 103               	.LBB51:
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix1[i] = 0x00;
 104               		.loc 1 69 0 discriminator 2
 105 0024 1192      		st Z+,__zero_reg__
 106               	.LVL4:
 107 0026 80E0      		ldi r24,hi8(_matrix1+8)
 108 0028 E030      		cpi r30,lo8(_matrix1+8)
 109 002a F807      		cpc r31,r24
 110 002c 01F4      		brne .L7
 111               	.LBE51:
  70:matrix.c      ****     matrix = _matrix0;
 112               		.loc 1 70 0
 113 002e 80E0      		ldi r24,lo8(_matrix0)
 114 0030 90E0      		ldi r25,hi8(_matrix0)
 115 0032 9093 0000 		sts matrix+1,r25
 116 0036 8093 0000 		sts matrix,r24
  71:matrix.c      ****     matrix_prev = _matrix1;
 117               		.loc 1 71 0
 118 003a 80E0      		ldi r24,lo8(_matrix1)
 119 003c 90E0      		ldi r25,hi8(_matrix1)
 120 003e 9093 0000 		sts matrix_prev+1,r25
 121 0042 8093 0000 		sts matrix_prev,r24
 122 0046 0895      		ret
 123               		.cfi_endproc
 124               	.LFE113:
 126               		.section	.text.matrix_scan,"ax",@progbits
 127               	.global	matrix_scan
 129               	matrix_scan:
 130               	.LFB114:
  72:matrix.c      **** }
  73:matrix.c      **** 
  74:matrix.c      **** uint8_t matrix_scan(void)
  75:matrix.c      **** {
 131               		.loc 1 75 0
 132               		.cfi_startproc
 133 0000 0F93      		push r16
 134               	.LCFI0:
 135               		.cfi_def_cfa_offset 3
 136               		.cfi_offset 16, -2
 137 0002 1F93      		push r17
 138               	.LCFI1:
 139               		.cfi_def_cfa_offset 4
 140               		.cfi_offset 17, -3
 141 0004 CF93      		push r28
 142               	.LCFI2:
 143               		.cfi_def_cfa_offset 5
 144               		.cfi_offset 28, -4
 145 0006 DF93      		push r29
 146               	.LCFI3:
 147               		.cfi_def_cfa_offset 6
 148               		.cfi_offset 29, -5
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 4 */
 152               	.L__stack_usage = 4
  76:matrix.c      ****     uint8_t *tmp;
  77:matrix.c      **** 
  78:matrix.c      ****     tmp = matrix_prev;
 153               		.loc 1 78 0
 154 0008 8091 0000 		lds r24,matrix_prev
 155 000c 9091 0000 		lds r25,matrix_prev+1
 156               	.LVL5:
  79:matrix.c      ****     matrix_prev = matrix;
 157               		.loc 1 79 0
 158 0010 2091 0000 		lds r18,matrix
 159 0014 3091 0000 		lds r19,matrix+1
 160 0018 3093 0000 		sts matrix_prev+1,r19
 161 001c 2093 0000 		sts matrix_prev,r18
  80:matrix.c      ****     matrix = tmp;
 162               		.loc 1 80 0
 163 0020 9093 0000 		sts matrix+1,r25
 164 0024 8093 0000 		sts matrix,r24
 165               	.LVL6:
 166 0028 C0E0      		ldi r28,0
 167 002a D0E0      		ldi r29,0
 168               	.LBB77:
 169               	.LBB78:
 170               	.LBB79:
  81:matrix.c      **** 
  82:matrix.c      ****     // power on
  83:matrix.c      ****     if (!KEY_POWER_STATE()) KEY_POWER_ON();
  84:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
  85:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
  86:matrix.c      ****             KEY_SELECT(row, col);
  87:matrix.c      ****             _delay_us(5);
  88:matrix.c      **** 
  89:matrix.c      ****             // Not sure this is needed. This just emulates HHKB controller's behaviour.
  90:matrix.c      ****             if (matrix_prev[row] & (1<<col)) {
  91:matrix.c      ****                 KEY_PREV_ON();
  92:matrix.c      ****             }
  93:matrix.c      ****             _delay_us(10);
  94:matrix.c      **** 
  95:matrix.c      ****             // NOTE: KEY_STATE is valid only in 20us after KEY_ENABLE.
  96:matrix.c      ****             // If V-USB interrupts in this section we could lose 40us or so
  97:matrix.c      ****             // and would read invalid value from KEY_STATE.
  98:matrix.c      ****             uint8_t last = TIMER_RAW;
  99:matrix.c      **** 
 100:matrix.c      ****             KEY_ENABLE();
 101:matrix.c      **** 
 102:matrix.c      ****             // Wait for KEY_STATE outputs its value.
 103:matrix.c      ****             // 1us was ok on one HHKB, but not worked on another.
 104:matrix.c      ****             // no   wait doesn't work on Teensy++ with pro(1us works)
 105:matrix.c      ****             // no   wait does    work on tmk PCB(8MHz) with pro2
 106:matrix.c      ****             // 1us  wait does    work on both of above
 107:matrix.c      ****             // 1us  wait doesn't work on tmk(16MHz)
 108:matrix.c      ****             // 5us  wait does    work on tmk(16MHz)
 109:matrix.c      ****             // 5us  wait does    work on tmk(16MHz/2)
 110:matrix.c      ****             // 5us  wait does    work on tmk(8MHz)
 111:matrix.c      ****             // 10us wait does    work on Teensy++ with pro
 112:matrix.c      ****             // 10us wait does    work on 328p+iwrap with pro
 113:matrix.c      ****             // 10us wait doesn't work on tmk PCB(8MHz) with pro2(very lagged scan)
 114:matrix.c      ****             _delay_us(5);
 115:matrix.c      **** 
 116:matrix.c      ****             if (KEY_STATE()) {
 117:matrix.c      ****                 matrix[row] &= ~(1<<col);
 118:matrix.c      ****             } else {
 119:matrix.c      ****                 matrix[row] |= (1<<col);
 171               		.loc 1 119 0
 172 002c 01E0      		ldi r16,lo8(1)
 173 002e 10E0      		ldi r17,0
 174               	.LVL7:
 175               	.L10:
 176               	.LBE79:
 177               	.LBE78:
 178               	.LBE77:
  75:matrix.c      ****     uint8_t *tmp;
 179               		.loc 1 75 0 discriminator 1
 180 0030 80E0      		ldi r24,0
 181 0032 90E0      		ldi r25,0
 182               	.LVL8:
 183               	.L22:
 184               	.LBB102:
 185               	.LBB101:
 186               	.LBB100:
 187               	.LBB80:
 188               	.LBB81:
  70:hhkb_avr.h    ****     
  71:hhkb_avr.h    ****     /* key: input with pull-up */
  72:hhkb_avr.h    **** /*    DDRD  &= ~0x80;
  73:hhkb_avr.h    ****     PORTD |=  0x80;*/
  74:hhkb_avr.h    **** #ifdef HHKB_JP
  75:hhkb_avr.h    ****     /* row extention for HHKB JP */
  76:hhkb_avr.h    ****     DDRC  |= (1<<6|1<<7);
  77:hhkb_avr.h    ****     PORTC |= (1<<6|1<<7);
  78:hhkb_avr.h    **** #endif
  79:hhkb_avr.h    ****     KEY_UNABLE();
  80:hhkb_avr.h    ****     KEY_PREV_OFF();
  81:hhkb_avr.h    **** 
  82:hhkb_avr.h    ****     KEY_POWER_OFF();
  83:hhkb_avr.h    **** }
  84:hhkb_avr.h    **** static inline void KEY_SELECT(uint8_t ROW, uint8_t COL)
  85:hhkb_avr.h    **** {
  86:hhkb_avr.h    ****     PORTB = (PORTB & 0xC0) | (((COL) & 0x07)<<3) | ((ROW) & 0x07);
 189               		.loc 2 86 0
 190 0034 45B1      		in r20,0x5
 191 0036 407C      		andi r20,lo8(-64)
 192 0038 4C2B      		or r20,r28
 193 003a 9C01      		movw r18,r24
 194 003c 53E0      		ldi r21,3
 195               		1:
 196 003e 220F      		lsl r18
 197 0040 331F      		rol r19
 198 0042 5A95      		dec r21
 199 0044 01F4      		brne 1b
 200 0046 422B      		or r20,r18
 201 0048 45B9      		out 0x5,r20
 202               	.LVL9:
 203               	.LBE81:
 204               	.LBE80:
 205               	.LBB82:
 206               	.LBB83:
 207               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 208               		.loc 3 245 0
 209 004a EAE1      		ldi r30,lo8(26)
 210 004c EA95      		1: dec r30
 211 004e 01F4      		brne 1b
 212 0050 00C0      		rjmp .
 213               	.LBE83:
 214               	.LBE82:
  90:matrix.c      ****                 KEY_PREV_ON();
 215               		.loc 1 90 0
 216 0052 E091 0000 		lds r30,matrix_prev
 217 0056 F091 0000 		lds r31,matrix_prev+1
 218 005a EC0F      		add r30,r28
 219 005c FD1F      		adc r31,r29
 220 005e 2081      		ld r18,Z
 221 0060 30E0      		ldi r19,0
 222 0062 082E      		mov r0,r24
 223 0064 00C0      		rjmp 2f
 224               		1:
 225 0066 3595      		asr r19
 226 0068 2795      		ror r18
 227               		2:
 228 006a 0A94      		dec r0
 229 006c 02F4      		brpl 1b
 230 006e 20FD      		sbrc r18,0
 231               	.LBB84:
 232               	.LBB85:
  42:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTF &= ~(1<<1)); }
 233               		.loc 2 42 0
 234 0070 899A      		sbi 0x11,1
 235               	.L11:
 236               	.LVL10:
 237               	.LBE85:
 238               	.LBE84:
 239               	.LBB86:
 240               	.LBB87:
 241               		.loc 3 245 0
 242 0072 F5E3      		ldi r31,lo8(53)
 243 0074 FA95      		1: dec r31
 244 0076 01F4      		brne 1b
 245 0078 0000      		nop
 246               	.LBE87:
 247               	.LBE86:
  98:matrix.c      **** 
 248               		.loc 1 98 0
 249 007a A6B5      		in r26,0x26
 250               	.LVL11:
 251               	.LBB88:
 252               	.LBB89:
  39:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
 253               		.loc 2 39 0
 254 007c 2E98      		cbi 0x5,6
 255               	.LVL12:
 256               	.LBE89:
 257               	.LBE88:
 258               	.LBB90:
 259               	.LBB91:
 260               		.loc 3 245 0
 261 007e 2AE1      		ldi r18,lo8(26)
 262 0080 2A95      		1: dec r18
 263 0082 01F4      		brne 1b
 264 0084 00C0      		rjmp .
 265 0086 2091 0000 		lds r18,matrix
 266 008a 3091 0000 		lds r19,matrix+1
 267               	.LBE91:
 268               	.LBE90:
 116:matrix.c      ****                 matrix[row] &= ~(1<<col);
 269               		.loc 1 116 0
 270 008e 789B      		sbis 0xf,0
 271 0090 00C0      		rjmp .L12
 117:matrix.c      ****             } else {
 272               		.loc 1 117 0
 273 0092 A801      		movw r20,r16
 274 0094 082E      		mov r0,r24
 275 0096 00C0      		rjmp 2f
 276               		1:
 277 0098 440F      		lsl r20
 278               		2:
 279 009a 0A94      		dec r0
 280 009c 02F4      		brpl 1b
 281 009e 4095      		com r20
 282 00a0 F901      		movw r30,r18
 283 00a2 EC0F      		add r30,r28
 284 00a4 FD1F      		adc r31,r29
 285 00a6 5081      		ld r21,Z
 286 00a8 5423      		and r21,r20
 287 00aa 5083      		st Z,r21
 288 00ac 00C0      		rjmp .L13
 289               	.L12:
 290               		.loc 1 119 0
 291 00ae F901      		movw r30,r18
 292 00b0 EC0F      		add r30,r28
 293 00b2 FD1F      		adc r31,r29
 294 00b4 6081      		ld r22,Z
 295 00b6 A801      		movw r20,r16
 296 00b8 082E      		mov r0,r24
 297 00ba 00C0      		rjmp 2f
 298               		1:
 299 00bc 440F      		lsl r20
 300               		2:
 301 00be 0A94      		dec r0
 302 00c0 02F4      		brpl 1b
 303 00c2 642B      		or r22,r20
 304 00c4 6083      		st Z,r22
 305               	.L13:
 120:matrix.c      ****             }
 121:matrix.c      **** 
 122:matrix.c      ****             // Ignore if this code region execution time elapses more than 20us.
 123:matrix.c      ****             // MEMO: 20[us] * (TIMER_RAW_FREQ / 1000000)[count per us]
 124:matrix.c      ****             // MEMO: then change above using this rule: a/(b/c) = a*1/(b/c) = a*(c/b)
 125:matrix.c      ****             if (TIMER_DIFF_RAW(TIMER_RAW, last) > 20/(1000000/TIMER_RAW_FREQ)) {
 306               		.loc 1 125 0
 307 00c6 46B5      		in r20,0x26
 308 00c8 6A2F      		mov r22,r26
 309 00ca 70E0      		ldi r23,0
 310 00cc 4A17      		cp r20,r26
 311 00ce 00F0      		brlo .L14
 312               	.LVL13:
 313               		.loc 1 125 0 is_stmt 0 discriminator 1
 314 00d0 46B5      		in r20,0x26
 315 00d2 50E0      		ldi r21,0
 316 00d4 00C0      		rjmp .L37
 317               	.L14:
 318               		.loc 1 125 0 discriminator 2
 319 00d6 46B5      		in r20,0x26
 320 00d8 50E0      		ldi r21,0
 321 00da 4150      		subi r20,1
 322 00dc 5F4F      		sbci r21,-1
 323               	.L37:
 324 00de 461B      		sub r20,r22
 325 00e0 570B      		sbc r21,r23
 326 00e2 4630      		cpi r20,6
 327 00e4 5105      		cpc r21,__zero_reg__
 328 00e6 00F0      		brlo .L18
 126:matrix.c      ****                 matrix[row] = matrix_prev[row];
 329               		.loc 1 126 0 is_stmt 1
 330 00e8 E091 0000 		lds r30,matrix_prev
 331 00ec F091 0000 		lds r31,matrix_prev+1
 332 00f0 EC0F      		add r30,r28
 333 00f2 FD1F      		adc r31,r29
 334 00f4 4081      		ld r20,Z
 335 00f6 F901      		movw r30,r18
 336 00f8 EC0F      		add r30,r28
 337 00fa FD1F      		adc r31,r29
 338 00fc 4083      		st Z,r20
 339               	.L18:
 340               	.LVL14:
 341               	.LBB92:
 342               	.LBB93:
 343               		.loc 3 245 0
 344 00fe EAE1      		ldi r30,lo8(26)
 345 0100 EA95      		1: dec r30
 346 0102 01F4      		brne 1b
 347 0104 00C0      		rjmp .
 348               	.LBE93:
 349               	.LBE92:
 350               	.LBB94:
 351               	.LBB95:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 352               		.loc 2 43 0
 353 0106 8998      		cbi 0x11,1
 354               	.LBE95:
 355               	.LBE94:
 356               	.LBB96:
 357               	.LBB97:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PINF & (1<<0)); }
 358               		.loc 2 40 0
 359 0108 2E9A      		sbi 0x5,6
 360               	.LVL15:
 361               	.LBE97:
 362               	.LBE96:
 363               	.LBB98:
 364               	.LBB99:
 365               		.loc 3 245 0
 366 010a EBE2      		ldi r30,lo8(299)
 367 010c F1E0      		ldi r31,hi8(299)
 368 010e 3197      		1: sbiw r30,1
 369 0110 01F4      		brne 1b
 370 0112 00C0      		rjmp .
 371 0114 0000      		nop
 372               	.LVL16:
 373 0116 0196      		adiw r24,1
 374               	.LVL17:
 375               	.LBE99:
 376               	.LBE98:
 377               	.LBE100:
  85:matrix.c      ****             KEY_SELECT(row, col);
 378               		.loc 1 85 0
 379 0118 8830      		cpi r24,8
 380 011a 9105      		cpc r25,__zero_reg__
 381 011c 01F0      		breq .+2
 382 011e 00C0      		rjmp .L22
 383               	.LBE101:
 127:matrix.c      ****             }
 128:matrix.c      **** 
 129:matrix.c      ****             _delay_us(5);
 130:matrix.c      ****             KEY_PREV_OFF();
 131:matrix.c      ****             KEY_UNABLE();
 132:matrix.c      **** 
 133:matrix.c      ****             // NOTE: KEY_STATE keep its state in 20us after KEY_ENABLE.
 134:matrix.c      ****             // This takes 25us or more to make sure KEY_STATE returns to idle state.
 135:matrix.c      **** #ifdef HHKB_JP
 136:matrix.c      ****             // Looks like JP needs faster scan due to its twice larger matrix
 137:matrix.c      ****             // or it can drop keys in fast key typing
 138:matrix.c      ****             _delay_us(30);
 139:matrix.c      **** #else
 140:matrix.c      ****             _delay_us(75);
 141:matrix.c      **** #endif
 142:matrix.c      ****         }
 143:matrix.c      ****         if (matrix[row] ^ matrix_prev[row]) matrix_last_modified = timer_read32();
 384               		.loc 1 143 0
 385 0120 A091 0000 		lds r26,matrix
 386 0124 B091 0000 		lds r27,matrix+1
 387 0128 AC0F      		add r26,r28
 388 012a BD1F      		adc r27,r29
 389 012c E091 0000 		lds r30,matrix_prev
 390 0130 F091 0000 		lds r31,matrix_prev+1
 391 0134 EC0F      		add r30,r28
 392 0136 FD1F      		adc r31,r29
 393 0138 9C91      		ld r25,X
 394 013a 8081      		ld r24,Z
 395               	.LVL18:
 396 013c 9817      		cp r25,r24
 397 013e 01F0      		breq .L20
 398               		.loc 1 143 0 is_stmt 0 discriminator 1
 399 0140 0E94 0000 		call timer_read32
 400               	.LVL19:
 401 0144 6093 0000 		sts matrix_last_modified,r22
 402 0148 7093 0000 		sts matrix_last_modified+1,r23
 403 014c 8093 0000 		sts matrix_last_modified+2,r24
 404 0150 9093 0000 		sts matrix_last_modified+3,r25
 405               	.L20:
 406               	.LVL20:
 407 0154 2196      		adiw r28,1
 408               	.LVL21:
  84:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
 409               		.loc 1 84 0 is_stmt 1
 410 0156 C830      		cpi r28,8
 411 0158 D105      		cpc r29,__zero_reg__
 412 015a 01F0      		breq .+2
 413 015c 00C0      		rjmp .L10
 414               	.LBE102:
 144:matrix.c      ****     }
 145:matrix.c      ****     // power off
 146:matrix.c      ****     if (KEY_POWER_STATE() &&
 147:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 415               		.loc 1 147 0 discriminator 1
 416 015e 8091 0000 		lds r24,USB_DeviceState
 146:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 417               		.loc 1 146 0 discriminator 1
 418 0162 8530      		cpi r24,lo8(5)
 419 0164 01F0      		breq .L23
 148:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 420               		.loc 1 148 0
 421 0166 8091 0000 		lds r24,USB_DeviceState
 147:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 422               		.loc 1 147 0
 423 016a 8111      		cpse r24,__zero_reg__
 424 016c 00C0      		rjmp .L24
 425               	.L23:
 149:matrix.c      ****             timer_elapsed32(matrix_last_modified) > MATRIX_POWER_SAVE) {
 426               		.loc 1 149 0
 427 016e 6091 0000 		lds r22,matrix_last_modified
 428 0172 7091 0000 		lds r23,matrix_last_modified+1
 429 0176 8091 0000 		lds r24,matrix_last_modified+2
 430 017a 9091 0000 		lds r25,matrix_last_modified+3
 431 017e 0E94 0000 		call timer_elapsed32
 432               	.LVL22:
 148:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 433               		.loc 1 148 0
 434 0182 6131      		cpi r22,17
 435 0184 7742      		sbci r23,39
 436 0186 8105      		cpc r24,__zero_reg__
 437 0188 9105      		cpc r25,__zero_reg__
 438 018a 00F0      		brlo .L24
 150:matrix.c      ****         KEY_POWER_OFF();
 151:matrix.c      ****         suspend_power_down();
 439               		.loc 1 151 0
 440 018c 0E94 0000 		call suspend_power_down
 441               	.LVL23:
 442               	.L24:
 152:matrix.c      ****     }
 153:matrix.c      ****     return 1;
 154:matrix.c      **** }
 443               		.loc 1 154 0
 444 0190 81E0      		ldi r24,lo8(1)
 445               	/* epilogue start */
 446 0192 DF91      		pop r29
 447 0194 CF91      		pop r28
 448               	.LVL24:
 449 0196 1F91      		pop r17
 450 0198 0F91      		pop r16
 451 019a 0895      		ret
 452               		.cfi_endproc
 453               	.LFE114:
 455               		.section	.text.matrix_is_modified,"ax",@progbits
 456               	.global	matrix_is_modified
 458               	matrix_is_modified:
 459               	.LFB115:
 155:matrix.c      **** 
 156:matrix.c      **** bool matrix_is_modified(void)
 157:matrix.c      **** {
 460               		.loc 1 157 0
 461               		.cfi_startproc
 462               	/* prologue: function */
 463               	/* frame size = 0 */
 464               	/* stack size = 0 */
 465               	.L__stack_usage = 0
 466               	.LVL25:
 467 0000 E091 0000 		lds r30,matrix
 468 0004 F091 0000 		lds r31,matrix+1
 469 0008 A091 0000 		lds r26,matrix_prev
 470 000c B091 0000 		lds r27,matrix_prev+1
 471               	.LBB103:
 158:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 472               		.loc 1 158 0
 473 0010 80E0      		ldi r24,0
 474               	.LVL26:
 475               	.L40:
 159:matrix.c      ****         if (matrix[i] != matrix_prev[i])
 476               		.loc 1 159 0
 477 0012 2191      		ld r18,Z+
 478 0014 9D91      		ld r25,X+
 479 0016 2913      		cpse r18,r25
 480 0018 00C0      		rjmp .L41
 158:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 481               		.loc 1 158 0
 482 001a 8F5F      		subi r24,lo8(-(1))
 483               	.LVL27:
 484 001c 8830      		cpi r24,lo8(8)
 485 001e 01F4      		brne .L40
 486               	.LBE103:
 160:matrix.c      ****             return true;
 161:matrix.c      ****     }
 162:matrix.c      ****     return false;
 487               		.loc 1 162 0
 488 0020 80E0      		ldi r24,0
 489               	.LVL28:
 163:matrix.c      **** }
 490               		.loc 1 163 0
 491 0022 0895      		ret
 492               	.LVL29:
 493               	.L41:
 494               	.LBB104:
 160:matrix.c      ****             return true;
 495               		.loc 1 160 0
 496 0024 81E0      		ldi r24,lo8(1)
 497               	.LVL30:
 498 0026 0895      		ret
 499               	.LBE104:
 500               		.cfi_endproc
 501               	.LFE115:
 503               		.section	.text.matrix_is_on,"ax",@progbits
 504               	.global	matrix_is_on
 506               	matrix_is_on:
 507               	.LFB117:
 164:matrix.c      **** 
 165:matrix.c      **** inline
 166:matrix.c      **** bool matrix_has_ghost(void)
 167:matrix.c      **** {
 168:matrix.c      ****     return false;
 169:matrix.c      **** }
 170:matrix.c      **** 
 171:matrix.c      **** inline
 172:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 173:matrix.c      **** {
 508               		.loc 1 173 0
 509               		.cfi_startproc
 510               	.LVL31:
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 0 */
 514               	.L__stack_usage = 0
 174:matrix.c      ****     return (matrix[row] & (1<<col));
 515               		.loc 1 174 0
 516 0000 E091 0000 		lds r30,matrix
 517 0004 F091 0000 		lds r31,matrix+1
 518 0008 E80F      		add r30,r24
 519 000a F11D      		adc r31,__zero_reg__
 520 000c 2081      		ld r18,Z
 521 000e 30E0      		ldi r19,0
 522 0010 81E0      		ldi r24,lo8(1)
 523 0012 90E0      		ldi r25,0
 524               	.LVL32:
 525 0014 00C0      		rjmp 2f
 526               		1:
 527 0016 880F      		lsl r24
 528 0018 991F      		rol r25
 529               		2:
 530 001a 6A95      		dec r22
 531 001c 02F4      		brpl 1b
 532 001e 2823      		and r18,r24
 533 0020 3923      		and r19,r25
 534 0022 81E0      		ldi r24,lo8(1)
 535 0024 232B      		or r18,r19
 536 0026 01F4      		brne .L44
 537 0028 80E0      		ldi r24,0
 538               	.L44:
 175:matrix.c      **** }
 539               		.loc 1 175 0
 540 002a 0895      		ret
 541               		.cfi_endproc
 542               	.LFE117:
 544               		.section	.text.matrix_get_row,"ax",@progbits
 545               	.global	matrix_get_row
 547               	matrix_get_row:
 548               	.LFB118:
 176:matrix.c      **** 
 177:matrix.c      **** inline
 178:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 179:matrix.c      **** {
 549               		.loc 1 179 0
 550               		.cfi_startproc
 551               	.LVL33:
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 180:matrix.c      ****     return matrix[row];
 556               		.loc 1 180 0
 557 0000 E091 0000 		lds r30,matrix
 558 0004 F091 0000 		lds r31,matrix+1
 559 0008 E80F      		add r30,r24
 560 000a F11D      		adc r31,__zero_reg__
 181:matrix.c      **** }
 561               		.loc 1 181 0
 562 000c 8081      		ld r24,Z
 563               	.LVL34:
 564 000e 0895      		ret
 565               		.cfi_endproc
 566               	.LFE118:
 568               		.section	.text.matrix_print,"ax",@progbits
 569               	.global	matrix_print
 571               	matrix_print:
 572               	.LFB119:
 182:matrix.c      **** 
 183:matrix.c      **** void matrix_print(void)
 184:matrix.c      **** {
 573               		.loc 1 184 0
 574               		.cfi_startproc
 575 0000 0F93      		push r16
 576               	.LCFI4:
 577               		.cfi_def_cfa_offset 3
 578               		.cfi_offset 16, -2
 579 0002 1F93      		push r17
 580               	.LCFI5:
 581               		.cfi_def_cfa_offset 4
 582               		.cfi_offset 17, -3
 583 0004 CF93      		push r28
 584               	.LCFI6:
 585               		.cfi_def_cfa_offset 5
 586               		.cfi_offset 28, -4
 587 0006 DF93      		push r29
 588               	.LCFI7:
 589               		.cfi_def_cfa_offset 6
 590               		.cfi_offset 29, -5
 591               	/* prologue: function */
 592               	/* frame size = 0 */
 593               	/* stack size = 4 */
 594               	.L__stack_usage = 4
 185:matrix.c      ****     print("\nr/c 01234567\n");
 595               		.loc 1 185 0
 596 0008 80E0      		ldi r24,lo8(__c.4556)
 597 000a 90E0      		ldi r25,hi8(__c.4556)
 598 000c 0E94 0000 		call xputs
 599               	.LVL35:
 600 0010 C0E0      		ldi r28,0
 601 0012 D0E0      		ldi r29,0
 602               	.LBB105:
 186:matrix.c      ****     for (uint8_t row = 0; row < matrix_rows(); row++) {
 187:matrix.c      ****         xprintf("%02X: %08b\n", row, bitrev(matrix_get_row(row)));
 603               		.loc 1 187 0
 604 0014 00E0      		ldi r16,lo8(__c.4559)
 605 0016 10E0      		ldi r17,hi8(__c.4559)
 606               	.LVL36:
 607               	.L48:
 608               	.LBB106:
 609               	.LBB107:
 180:matrix.c      **** }
 610               		.loc 1 180 0
 611 0018 E091 0000 		lds r30,matrix
 612 001c F091 0000 		lds r31,matrix+1
 613 0020 EC0F      		add r30,r28
 614 0022 FD1F      		adc r31,r29
 615               	.LBE107:
 616               	.LBE106:
 617               		.loc 1 187 0
 618 0024 8081      		ld r24,Z
 619 0026 0E94 0000 		call bitrev
 620               	.LVL37:
 621 002a 1F92      		push __zero_reg__
 622               	.LCFI8:
 623               		.cfi_def_cfa_offset 7
 624 002c 8F93      		push r24
 625               	.LCFI9:
 626               		.cfi_def_cfa_offset 8
 627 002e DF93      		push r29
 628               	.LCFI10:
 629               		.cfi_def_cfa_offset 9
 630 0030 CF93      		push r28
 631               	.LCFI11:
 632               		.cfi_def_cfa_offset 10
 633 0032 1F93      		push r17
 634               	.LCFI12:
 635               		.cfi_def_cfa_offset 11
 636 0034 0F93      		push r16
 637               	.LCFI13:
 638               		.cfi_def_cfa_offset 12
 639 0036 0E94 0000 		call __xprintf
 640               	.LVL38:
 641 003a 2196      		adiw r28,1
 642               	.LVL39:
 186:matrix.c      ****     for (uint8_t row = 0; row < matrix_rows(); row++) {
 643               		.loc 1 186 0
 644 003c 0F90      		pop __tmp_reg__
 645 003e 0F90      		pop __tmp_reg__
 646 0040 0F90      		pop __tmp_reg__
 647 0042 0F90      		pop __tmp_reg__
 648 0044 0F90      		pop __tmp_reg__
 649 0046 0F90      		pop __tmp_reg__
 650               	.LCFI14:
 651               		.cfi_def_cfa_offset 6
 652 0048 C830      		cpi r28,8
 653 004a D105      		cpc r29,__zero_reg__
 654 004c 01F4      		brne .L48
 655               	/* epilogue start */
 656               	.LBE105:
 188:matrix.c      ****     }
 189:matrix.c      **** }
 657               		.loc 1 189 0
 658 004e DF91      		pop r29
 659 0050 CF91      		pop r28
 660               	.LVL40:
 661 0052 1F91      		pop r17
 662 0054 0F91      		pop r16
 663 0056 0895      		ret
 664               		.cfi_endproc
 665               	.LFE119:
 667               		.section	.text.matrix_power_up,"ax",@progbits
 668               	.global	matrix_power_up
 670               	matrix_power_up:
 671               	.LFB120:
 190:matrix.c      **** 
 191:matrix.c      **** void matrix_power_up(void) {
 672               		.loc 1 191 0
 673               		.cfi_startproc
 674               	/* prologue: function */
 675               	/* frame size = 0 */
 676               	/* stack size = 0 */
 677               	.L__stack_usage = 0
 678 0000 0895      		ret
 679               		.cfi_endproc
 680               	.LFE120:
 682               		.section	.text.matrix_power_down,"ax",@progbits
 683               	.global	matrix_power_down
 685               	matrix_power_down:
 686               	.LFB121:
 192:matrix.c      ****     KEY_POWER_ON();
 193:matrix.c      **** }
 194:matrix.c      **** void matrix_power_down(void) {
 687               		.loc 1 194 0
 688               		.cfi_startproc
 689               	/* prologue: function */
 690               	/* frame size = 0 */
 691               	/* stack size = 0 */
 692               	.L__stack_usage = 0
 693 0000 0895      		ret
 694               		.cfi_endproc
 695               	.LFE121:
 697               		.section	.progmem.data.__c.4559,"a",@progbits
 700               	__c.4559:
 701 0000 2530 3258 		.string	"%02X: %08b\n"
 701      3A20 2530 
 701      3862 0A00 
 702               		.section	.progmem.data.__c.4556,"a",@progbits
 705               	__c.4556:
 706 0000 0A72 2F63 		.string	"\nr/c 01234567\n"
 706      2030 3132 
 706      3334 3536 
 706      370A 00
 707               		.section	.bss._matrix1,"aw",@nobits
 710               	_matrix1:
 711 0000 0000 0000 		.zero	8
 711      0000 0000 
 712               		.section	.bss._matrix0,"aw",@nobits
 715               	_matrix0:
 716 0000 0000 0000 		.zero	8
 716      0000 0000 
 717               		.section	.bss.matrix_prev,"aw",@nobits
 720               	matrix_prev:
 721 0000 0000      		.zero	2
 722               		.section	.bss.matrix,"aw",@nobits
 725               	matrix:
 726 0000 0000      		.zero	2
 727               		.section	.bss.matrix_last_modified,"aw",@nobits
 730               	matrix_last_modified:
 731 0000 0000 0000 		.zero	4
 732               		.text
 733               	.Letext0:
 734               		.file 4 "/usr/lib/avr/include/stdint.h"
 735               		.file 5 "../../tmk_core/common/matrix.h"
 736               		.file 6 "../../tmk_core/common/timer.h"
 737               		.file 7 "../../tmk_core/common/suspend.h"
 738               		.file 8 "../../tmk_core/common/util.h"
 739               		.file 9 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../Device.h"
 740               		.file 10 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 741               		.file 11 "../../tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccGNOEGH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccGNOEGH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccGNOEGH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccGNOEGH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccGNOEGH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccGNOEGH.s:13     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccGNOEGH.s:31     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccGNOEGH.s:48     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccGNOEGH.s:715    .bss._matrix0:0000000000000000 _matrix0
     /tmp/ccGNOEGH.s:710    .bss._matrix1:0000000000000000 _matrix1
     /tmp/ccGNOEGH.s:725    .bss.matrix:0000000000000000 matrix
     /tmp/ccGNOEGH.s:720    .bss.matrix_prev:0000000000000000 matrix_prev
     /tmp/ccGNOEGH.s:129    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccGNOEGH.s:730    .bss.matrix_last_modified:0000000000000000 matrix_last_modified
     /tmp/ccGNOEGH.s:458    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccGNOEGH.s:506    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccGNOEGH.s:547    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccGNOEGH.s:571    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccGNOEGH.s:705    .progmem.data.__c.4556:0000000000000000 __c.4556
     /tmp/ccGNOEGH.s:700    .progmem.data.__c.4559:0000000000000000 __c.4559
     /tmp/ccGNOEGH.s:670    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccGNOEGH.s:685    .text.matrix_power_down:0000000000000000 matrix_power_down

UNDEFINED SYMBOLS
timer_read32
USB_DeviceState
timer_elapsed32
suspend_power_down
xputs
bitrev
__xprintf
__do_clear_bss
