   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_rows,"ax",@progbits
  11               	.global	matrix_rows
  13               	matrix_rows:
  14               	.LFB115:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2011 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <util/delay.h>
  24:matrix.c      **** #include "print.h"
  25:matrix.c      **** #include "debug.h"
  26:matrix.c      **** #include "util.h"
  27:matrix.c      **** #include "timer.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** #include "hhkb_avr.h"
  30:matrix.c      **** #include <avr/wdt.h>
  31:matrix.c      **** #include "suspend.h"
  32:matrix.c      **** #include "lufa.h"
  33:matrix.c      **** 
  34:matrix.c      **** 
  35:matrix.c      **** // matrix power saving
  36:matrix.c      **** #define MATRIX_POWER_SAVE       10000
  37:matrix.c      **** static uint32_t matrix_last_modified = 0;
  38:matrix.c      **** 
  39:matrix.c      **** // matrix state buffer(1:on, 0:off)
  40:matrix.c      **** static matrix_row_t *matrix;
  41:matrix.c      **** static matrix_row_t *matrix_prev;
  42:matrix.c      **** static matrix_row_t _matrix0[MATRIX_ROWS];
  43:matrix.c      **** static matrix_row_t _matrix1[MATRIX_ROWS];
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  16               		.loc 1 48 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  22               		.loc 1 50 0
  23 0000 88E0      		ldi r24,lo8(8)
  24 0002 0895      		ret
  25               		.cfi_endproc
  26               	.LFE115:
  28               		.section	.text.matrix_cols,"ax",@progbits
  29               	.global	matrix_cols
  31               	matrix_cols:
  32               	.LFB116:
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  33               		.loc 1 54 0
  34               		.cfi_startproc
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 0 */
  38               	.L__stack_usage = 0
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  39               		.loc 1 56 0
  40 0000 88E0      		ldi r24,lo8(8)
  41 0002 0895      		ret
  42               		.cfi_endproc
  43               	.LFE116:
  45               		.section	.text.matrix_init,"ax",@progbits
  46               	.global	matrix_init
  48               	matrix_init:
  49               	.LFB117:
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  50               		.loc 1 59 0
  51               		.cfi_startproc
  52               	/* prologue: function */
  53               	/* frame size = 0 */
  54               	/* stack size = 0 */
  55               	.L__stack_usage = 0
  56               	.LBB44:
  57               	.LBB45:
  58               		.file 2 "hhkb_avr.h"
   1:hhkb_avr.h    **** #ifndef HHKB_AVR_H
   2:hhkb_avr.h    **** #define HHKB_AVR_H
   3:hhkb_avr.h    **** 
   4:hhkb_avr.h    **** #include <stdint.h>
   5:hhkb_avr.h    **** #include <stdbool.h>
   6:hhkb_avr.h    **** #include <avr/io.h>
   7:hhkb_avr.h    **** #include <avr/interrupt.h>
   8:hhkb_avr.h    **** #include <util/delay.h>
   9:hhkb_avr.h    **** 
  10:hhkb_avr.h    **** 
  11:hhkb_avr.h    **** // Timer resolution check
  12:hhkb_avr.h    **** #if (1000000/TIMER_RAW_FREQ > 20)
  13:hhkb_avr.h    **** #   error "Timer resolution(>20us) is not enough for HHKB matrix scan tweak on V-USB."
  14:hhkb_avr.h    **** #endif
  15:hhkb_avr.h    **** 
  16:hhkb_avr.h    **** 
  17:hhkb_avr.h    **** /*
  18:hhkb_avr.h    ****  * HHKB Matrix I/O
  19:hhkb_avr.h    ****  *
  20:hhkb_avr.h    ****  * row:     HC4051[A,B,C]  selects scan row0-7
  21:hhkb_avr.h    ****  * row-ext: [En0,En1] row extention for JP
  22:hhkb_avr.h    ****  * col:     LS145[A,B,C,D] selects scan col0-7 and enable(D)
  23:hhkb_avr.h    ****  * key:     on: 0/off: 1
  24:hhkb_avr.h    ****  * prev:    hysteresis control: assert(1) when previous key state is on
  25:hhkb_avr.h    ****  */
  26:hhkb_avr.h    **** 
  27:hhkb_avr.h    **** 
  28:hhkb_avr.h    **** #if defined(__AVR_ATmega32U4__)
  29:hhkb_avr.h    **** /*
  30:hhkb_avr.h    ****  * For TMK HHKB alt controller(ATMega32U4)
  31:hhkb_avr.h    ****  *
  32:hhkb_avr.h    ****  * row:     PB0-2
  33:hhkb_avr.h    ****  * col:     PB3-5,6
  34:hhkb_avr.h    ****  * key:     PD7(pull-uped)
  35:hhkb_avr.h    ****  * prev:    PB7
  36:hhkb_avr.h    ****  * power:   PD4(L:off/H:on)
  37:hhkb_avr.h    ****  * row-ext: PC6,7 for HHKB JP(active low)
  38:hhkb_avr.h    ****  */
  39:hhkb_avr.h    **** static inline void KEY_ENABLE(void) { (PORTB &= ~(1<<6)); }
  40:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
  41:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PINF & (1<<0)); }
  42:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTF |=  (1<<1)); }
  43:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTF &= ~(1<<1)); }
  44:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
  45:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {
  46:hhkb_avr.h    ****     DDRB = 0xFF; PORTB = 0x40;          // change pins output
  47:hhkb_avr.h    ****  //   DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  48:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  49:hhkb_avr.h    ****     _delay_ms(5);                       // wait for powering up
  50:hhkb_avr.h    **** }
  51:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {
  52:hhkb_avr.h    ****     /* input with pull-up consumes less than without it when pin is open. */
  53:hhkb_avr.h    ****     DDRB = 0x00; PORTB = 0xFF;          // change pins input with pull-up
  54:hhkb_avr.h    ****  //   DDRD |= (1<<4); PORTD &= ~(1<<4);   // MOS FET switch off
  55:hhkb_avr.h    **** }
  56:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return PORTD & (1<<4); }
  57:hhkb_avr.h    **** #else
  58:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {}
  59:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {}
  60:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return true; }
  61:hhkb_avr.h    **** #endif
  62:hhkb_avr.h    **** static inline void KEY_INIT(void)
  63:hhkb_avr.h    **** {
  64:hhkb_avr.h    ****     /* row,col,prev: output */
  65:hhkb_avr.h    ****     DDRB  = 0xFF;
  59               		.loc 2 65 0
  60 0000 8FEF      		ldi r24,lo8(-1)
  61 0002 84B9      		out 0x4,r24
  66:hhkb_avr.h    ****     PORTB = 0x40;   // unable
  62               		.loc 2 66 0
  63 0004 80E4      		ldi r24,lo8(64)
  64 0006 85B9      		out 0x5,r24
  67:hhkb_avr.h    ****     DDRF |= (1<<1);
  65               		.loc 2 67 0
  66 0008 819A      		sbi 0x10,1
  68:hhkb_avr.h    ****     DDRF &= ~(1<<0);
  67               		.loc 2 68 0
  68 000a 8098      		cbi 0x10,0
  69:hhkb_avr.h    ****     PORTF |= (1<<0);
  69               		.loc 2 69 0
  70 000c 889A      		sbi 0x11,0
  71               	.LBB46:
  72               	.LBB47:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PINF & (1<<0)); }
  73               		.loc 2 40 0
  74 000e 2E9A      		sbi 0x5,6
  75               	.LBE47:
  76               	.LBE46:
  77               	.LBB48:
  78               	.LBB49:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
  79               		.loc 2 43 0
  80 0010 8998      		cbi 0x11,1
  81               	.LVL0:
  82 0012 E0E0      		ldi r30,lo8(_matrix0)
  83 0014 F0E0      		ldi r31,hi8(_matrix0)
  84 0016 88E0      		ldi r24,lo8(8)
  85 0018 8E0F      		add r24,r30
  86               	.LVL1:
  87               	.L4:
  88               	.LBE49:
  89               	.LBE48:
  90               	.LBE45:
  91               	.LBE44:
  92               	.LBB50:
  60:matrix.c      **** #ifdef DEBUG
  61:matrix.c      ****     debug_enable = true;
  62:matrix.c      ****     debug_keyboard = true;
  63:matrix.c      **** #endif
  64:matrix.c      **** 
  65:matrix.c      ****     KEY_INIT();
  66:matrix.c      **** 
  67:matrix.c      ****     // initialize matrix state: all keys off
  68:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix0[i] = 0x00;
  93               		.loc 1 68 0 discriminator 3
  94 001a 1192      		st Z+,__zero_reg__
  95               	.LVL2:
  96 001c 8E13      		cpse r24,r30
  97 001e 00C0      		rjmp .L4
  98               		.loc 1 68 0 is_stmt 0
  99 0020 E0E0      		ldi r30,lo8(_matrix1)
 100 0022 F0E0      		ldi r31,hi8(_matrix1)
 101               	.LVL3:
 102 0024 88E0      		ldi r24,lo8(8)
 103 0026 8E0F      		add r24,r30
 104               	.L5:
 105               	.LVL4:
 106               	.LBE50:
 107               	.LBB51:
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix1[i] = 0x00;
 108               		.loc 1 69 0 is_stmt 1 discriminator 3
 109 0028 1192      		st Z+,__zero_reg__
 110               	.LVL5:
 111 002a 8E13      		cpse r24,r30
 112 002c 00C0      		rjmp .L5
 113               	.LBE51:
  70:matrix.c      ****     matrix = _matrix0;
 114               		.loc 1 70 0
 115 002e 80E0      		ldi r24,lo8(_matrix0)
 116 0030 90E0      		ldi r25,hi8(_matrix0)
 117 0032 9093 0000 		sts matrix+1,r25
 118 0036 8093 0000 		sts matrix,r24
  71:matrix.c      ****     matrix_prev = _matrix1;
 119               		.loc 1 71 0
 120 003a 80E0      		ldi r24,lo8(_matrix1)
 121 003c 90E0      		ldi r25,hi8(_matrix1)
 122 003e 9093 0000 		sts matrix_prev+1,r25
 123 0042 8093 0000 		sts matrix_prev,r24
 124 0046 0895      		ret
 125               		.cfi_endproc
 126               	.LFE117:
 128               		.section	.text.matrix_scan,"ax",@progbits
 129               	.global	matrix_scan
 131               	matrix_scan:
 132               	.LFB118:
  72:matrix.c      **** }
  73:matrix.c      **** 
  74:matrix.c      **** uint8_t matrix_scan(void)
  75:matrix.c      **** {
 133               		.loc 1 75 0
 134               		.cfi_startproc
 135 0000 0F93      		push r16
 136               	.LCFI0:
 137               		.cfi_def_cfa_offset 3
 138               		.cfi_offset 16, -2
 139 0002 1F93      		push r17
 140               	.LCFI1:
 141               		.cfi_def_cfa_offset 4
 142               		.cfi_offset 17, -3
 143 0004 CF93      		push r28
 144               	.LCFI2:
 145               		.cfi_def_cfa_offset 5
 146               		.cfi_offset 28, -4
 147 0006 DF93      		push r29
 148               	.LCFI3:
 149               		.cfi_def_cfa_offset 6
 150               		.cfi_offset 29, -5
 151               	/* prologue: function */
 152               	/* frame size = 0 */
 153               	/* stack size = 4 */
 154               	.L__stack_usage = 4
  76:matrix.c      ****     uint8_t *tmp;
  77:matrix.c      **** 
  78:matrix.c      ****     tmp = matrix_prev;
 155               		.loc 1 78 0
 156 0008 8091 0000 		lds r24,matrix_prev
 157 000c 9091 0000 		lds r25,matrix_prev+1
 158               	.LVL6:
  79:matrix.c      ****     matrix_prev = matrix;
 159               		.loc 1 79 0
 160 0010 2091 0000 		lds r18,matrix
 161 0014 3091 0000 		lds r19,matrix+1
 162 0018 3093 0000 		sts matrix_prev+1,r19
 163 001c 2093 0000 		sts matrix_prev,r18
  80:matrix.c      ****     matrix = tmp;
 164               		.loc 1 80 0
 165 0020 9093 0000 		sts matrix+1,r25
 166 0024 8093 0000 		sts matrix,r24
 167               	.LVL7:
 168 0028 C0E0      		ldi r28,0
 169 002a D0E0      		ldi r29,0
 170               	.LBB77:
 171               	.LBB78:
 172               	.LBB79:
  81:matrix.c      **** 
  82:matrix.c      ****     // power on
  83:matrix.c      ****     if (!KEY_POWER_STATE()) KEY_POWER_ON();
  84:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
  85:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
  86:matrix.c      ****             KEY_SELECT(row, col);
  87:matrix.c      ****             _delay_us(5);
  88:matrix.c      **** 
  89:matrix.c      ****             // Not sure this is needed. This just emulates HHKB controller's behaviour.
  90:matrix.c      ****             if (matrix_prev[row] & (1<<col)) {
  91:matrix.c      ****                 KEY_PREV_ON();
  92:matrix.c      ****             }
  93:matrix.c      ****             _delay_us(10);
  94:matrix.c      **** 
  95:matrix.c      ****             // NOTE: KEY_STATE is valid only in 20us after KEY_ENABLE.
  96:matrix.c      ****             // If V-USB interrupts in this section we could lose 40us or so
  97:matrix.c      ****             // and would read invalid value from KEY_STATE.
  98:matrix.c      ****             uint8_t last = TIMER_RAW;
  99:matrix.c      **** 
 100:matrix.c      ****             KEY_ENABLE();
 101:matrix.c      **** 
 102:matrix.c      ****             // Wait for KEY_STATE outputs its value.
 103:matrix.c      ****             // 1us was ok on one HHKB, but not worked on another.
 104:matrix.c      ****             // no   wait doesn't work on Teensy++ with pro(1us works)
 105:matrix.c      ****             // no   wait does    work on tmk PCB(8MHz) with pro2
 106:matrix.c      ****             // 1us  wait does    work on both of above
 107:matrix.c      ****             // 1us  wait doesn't work on tmk(16MHz)
 108:matrix.c      ****             // 5us  wait does    work on tmk(16MHz)
 109:matrix.c      ****             // 5us  wait does    work on tmk(16MHz/2)
 110:matrix.c      ****             // 5us  wait does    work on tmk(8MHz)
 111:matrix.c      ****             // 10us wait does    work on Teensy++ with pro
 112:matrix.c      ****             // 10us wait does    work on 328p+iwrap with pro
 113:matrix.c      ****             // 10us wait doesn't work on tmk PCB(8MHz) with pro2(very lagged scan)
 114:matrix.c      ****             _delay_us(5);
 115:matrix.c      **** 
 116:matrix.c      ****             if (KEY_STATE()) {
 117:matrix.c      ****                 matrix[row] &= ~(1<<col);
 118:matrix.c      ****             } else {
 119:matrix.c      ****                 matrix[row] |= (1<<col);
 173               		.loc 1 119 0
 174 002c 01E0      		ldi r16,lo8(1)
 175 002e 10E0      		ldi r17,0
 176               	.LVL8:
 177               	.L10:
 178               	.LBE79:
 179               	.LBE78:
 180               	.LBE77:
  75:matrix.c      ****     uint8_t *tmp;
 181               		.loc 1 75 0
 182 0030 80E0      		ldi r24,0
 183 0032 90E0      		ldi r25,0
 184               	.LVL9:
 185               	.L19:
 186               	.LBB102:
 187               	.LBB101:
 188               	.LBB100:
 189               	.LBB80:
 190               	.LBB81:
  70:hhkb_avr.h    ****     
  71:hhkb_avr.h    ****     /* key: input with pull-up */
  72:hhkb_avr.h    **** /*    DDRD  &= ~0x80;
  73:hhkb_avr.h    ****     PORTD |=  0x80;*/
  74:hhkb_avr.h    **** #ifdef HHKB_JP
  75:hhkb_avr.h    ****     /* row extention for HHKB JP */
  76:hhkb_avr.h    ****     DDRC  |= (1<<6|1<<7);
  77:hhkb_avr.h    ****     PORTC |= (1<<6|1<<7);
  78:hhkb_avr.h    **** #endif
  79:hhkb_avr.h    ****     KEY_UNABLE();
  80:hhkb_avr.h    ****     KEY_PREV_OFF();
  81:hhkb_avr.h    **** 
  82:hhkb_avr.h    ****     KEY_POWER_OFF();
  83:hhkb_avr.h    **** }
  84:hhkb_avr.h    **** static inline void KEY_SELECT(uint8_t ROW, uint8_t COL)
  85:hhkb_avr.h    **** {
  86:hhkb_avr.h    ****     PORTB = (PORTB & 0xC0) | (((COL) & 0x07)<<3) | ((ROW) & 0x07);
 191               		.loc 2 86 0
 192 0034 25B1      		in r18,0x5
 193 0036 207C      		andi r18,lo8(-64)
 194 0038 2C2B      		or r18,r28
 195 003a AC01      		movw r20,r24
 196 003c 33E0      		ldi r19,3
 197               		1:
 198 003e 440F      		lsl r20
 199 0040 551F      		rol r21
 200 0042 3A95      		dec r19
 201 0044 01F4      		brne 1b
 202 0046 242B      		or r18,r20
 203 0048 25B9      		out 0x5,r18
 204               	.LVL10:
 205               	.LBE81:
 206               	.LBE80:
 207               	.LBB82:
 208               	.LBB83:
 209               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 210               		.loc 3 245 0
 211 004a EAE1      		ldi r30,lo8(26)
 212 004c EA95      	1:	dec r30
 213 004e 01F4      		brne 1b
 214 0050 00C0      		rjmp .
 215               	.LBE83:
 216               	.LBE82:
  90:matrix.c      ****                 KEY_PREV_ON();
 217               		.loc 1 90 0
 218 0052 E091 0000 		lds r30,matrix_prev
 219 0056 F091 0000 		lds r31,matrix_prev+1
 220 005a EC0F      		add r30,r28
 221 005c FD1F      		adc r31,r29
 222 005e 2081      		ld r18,Z
 223 0060 30E0      		ldi r19,0
 224 0062 082E      		mov r0,r24
 225 0064 00C0      		rjmp 2f
 226               		1:
 227 0066 3595      		asr r19
 228 0068 2795      		ror r18
 229               		2:
 230 006a 0A94      		dec r0
 231 006c 02F4      		brpl 1b
 232 006e 20FD      		sbrc r18,0
 233               	.LBB84:
 234               	.LBB85:
  42:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTF &= ~(1<<1)); }
 235               		.loc 2 42 0
 236 0070 899A      		sbi 0x11,1
 237               	.L11:
 238               	.LVL11:
 239               	.LBE85:
 240               	.LBE84:
 241               	.LBB86:
 242               	.LBB87:
 243               		.loc 3 245 0
 244 0072 F5E3      		ldi r31,lo8(53)
 245 0074 FA95      	1:	dec r31
 246 0076 01F4      		brne 1b
 247 0078 0000      		nop
 248               	.LBE87:
 249               	.LBE86:
  98:matrix.c      **** 
 250               		.loc 1 98 0
 251 007a E6B5      		in r30,0x26
 252               	.LVL12:
 253               	.LBB88:
 254               	.LBB89:
  39:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
 255               		.loc 2 39 0
 256 007c 2E98      		cbi 0x5,6
 257               	.LVL13:
 258               	.LBE89:
 259               	.LBE88:
 260               	.LBB90:
 261               	.LBB91:
 262               		.loc 3 245 0
 263 007e 2AE1      		ldi r18,lo8(26)
 264 0080 2A95      	1:	dec r18
 265 0082 01F4      		brne 1b
 266 0084 00C0      		rjmp .
 267 0086 4091 0000 		lds r20,matrix
 268 008a 5091 0000 		lds r21,matrix+1
 269               	.LBE91:
 270               	.LBE90:
 117:matrix.c      ****             } else {
 271               		.loc 1 117 0
 272 008e DA01      		movw r26,r20
 273 0090 AC0F      		add r26,r28
 274 0092 BD1F      		adc r27,r29
 116:matrix.c      ****                 matrix[row] &= ~(1<<col);
 275               		.loc 1 116 0
 276 0094 789B      		sbis 0xf,0
 277 0096 00C0      		rjmp .L12
 117:matrix.c      ****             } else {
 278               		.loc 1 117 0
 279 0098 9801      		movw r18,r16
 280 009a 082E      		mov r0,r24
 281 009c 00C0      		rjmp 2f
 282               		1:
 283 009e 220F      		lsl r18
 284               		2:
 285 00a0 0A94      		dec r0
 286 00a2 02F4      		brpl 1b
 287 00a4 2095      		com r18
 288 00a6 3C91      		ld r19,X
 289 00a8 2323      		and r18,r19
 290 00aa 00C0      		rjmp .L37
 291               	.L12:
 292               		.loc 1 119 0
 293 00ac 6C91      		ld r22,X
 294 00ae 9801      		movw r18,r16
 295 00b0 082E      		mov r0,r24
 296 00b2 00C0      		rjmp 2f
 297               		1:
 298 00b4 220F      		lsl r18
 299               		2:
 300 00b6 0A94      		dec r0
 301 00b8 02F4      		brpl 1b
 302 00ba 262B      		or r18,r22
 303               	.L37:
 304 00bc 2C93      		st X,r18
 120:matrix.c      ****             }
 121:matrix.c      **** 
 122:matrix.c      ****             // Ignore if this code region execution time elapses more than 20us.
 123:matrix.c      ****             // MEMO: 20[us] * (TIMER_RAW_FREQ / 1000000)[count per us]
 124:matrix.c      ****             // MEMO: then change above using this rule: a/(b/c) = a*1/(b/c) = a*(c/b)
 125:matrix.c      ****             if (TIMER_DIFF_RAW(TIMER_RAW, last) > 20/(1000000/TIMER_RAW_FREQ)) {
 305               		.loc 1 125 0
 306 00be 26B5      		in r18,0x26
 307 00c0 6E2F      		mov r22,r30
 308 00c2 70E0      		ldi r23,0
 309 00c4 2E17      		cp r18,r30
 310 00c6 00F0      		brlo .L14
 311               	.LVL14:
 312               		.loc 1 125 0 is_stmt 0 discriminator 1
 313 00c8 26B5      		in r18,0x26
 314 00ca 30E0      		ldi r19,0
 315 00cc 00C0      		rjmp .L38
 316               	.L14:
 317               		.loc 1 125 0 discriminator 2
 318 00ce 26B5      		in r18,0x26
 319 00d0 30E0      		ldi r19,0
 320 00d2 2150      		subi r18,1
 321 00d4 3F4F      		sbci r19,-1
 322               	.L38:
 323 00d6 261B      		sub r18,r22
 324 00d8 370B      		sbc r19,r23
 325 00da 2630      		cpi r18,6
 326 00dc 3105      		cpc r19,__zero_reg__
 327 00de 00F0      		brlo .L18
 126:matrix.c      ****                 matrix[row] = matrix_prev[row];
 328               		.loc 1 126 0 is_stmt 1
 329 00e0 E091 0000 		lds r30,matrix_prev
 330 00e4 F091 0000 		lds r31,matrix_prev+1
 331 00e8 EC0F      		add r30,r28
 332 00ea FD1F      		adc r31,r29
 333 00ec 2081      		ld r18,Z
 334 00ee FA01      		movw r30,r20
 335 00f0 EC0F      		add r30,r28
 336 00f2 FD1F      		adc r31,r29
 337 00f4 2083      		st Z,r18
 338               	.L18:
 339               	.LVL15:
 340               	.LBB92:
 341               	.LBB93:
 342               		.loc 3 245 0 discriminator 2
 343 00f6 3AE1      		ldi r19,lo8(26)
 344 00f8 3A95      	1:	dec r19
 345 00fa 01F4      		brne 1b
 346 00fc 00C0      		rjmp .
 347               	.LBE93:
 348               	.LBE92:
 349               	.LBB94:
 350               	.LBB95:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 351               		.loc 2 43 0 discriminator 2
 352 00fe 8998      		cbi 0x11,1
 353               	.LBE95:
 354               	.LBE94:
 355               	.LBB96:
 356               	.LBB97:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PINF & (1<<0)); }
 357               		.loc 2 40 0 discriminator 2
 358 0100 2E9A      		sbi 0x5,6
 359               	.LVL16:
 360               	.LBE97:
 361               	.LBE96:
 362               	.LBB98:
 363               	.LBB99:
 364               		.loc 3 245 0 discriminator 2
 365 0102 EBE2      		ldi r30,lo8(299)
 366 0104 F1E0      		ldi r31,hi8(299)
 367 0106 3197      	1:	sbiw r30,1
 368 0108 01F4      		brne 1b
 369 010a 00C0      		rjmp .
 370 010c 0000      		nop
 371               	.LVL17:
 372 010e 0196      		adiw r24,1
 373               	.LVL18:
 374               	.LBE99:
 375               	.LBE98:
 376               	.LBE100:
  85:matrix.c      ****             KEY_SELECT(row, col);
 377               		.loc 1 85 0 discriminator 2
 378 0110 8830      		cpi r24,8
 379 0112 9105      		cpc r25,__zero_reg__
 380 0114 01F0      		breq .+2
 381 0116 00C0      		rjmp .L19
 382               	.LBE101:
 127:matrix.c      ****             }
 128:matrix.c      **** 
 129:matrix.c      ****             _delay_us(5);
 130:matrix.c      ****             KEY_PREV_OFF();
 131:matrix.c      ****             KEY_UNABLE();
 132:matrix.c      **** 
 133:matrix.c      ****             // NOTE: KEY_STATE keep its state in 20us after KEY_ENABLE.
 134:matrix.c      ****             // This takes 25us or more to make sure KEY_STATE returns to idle state.
 135:matrix.c      **** #ifdef HHKB_JP
 136:matrix.c      ****             // Looks like JP needs faster scan due to its twice larger matrix
 137:matrix.c      ****             // or it can drop keys in fast key typing
 138:matrix.c      ****             _delay_us(30);
 139:matrix.c      **** #else
 140:matrix.c      ****             _delay_us(75);
 141:matrix.c      **** #endif
 142:matrix.c      ****         }
 143:matrix.c      ****         if (matrix[row] ^ matrix_prev[row]) matrix_last_modified = timer_read32();
 383               		.loc 1 143 0
 384 0118 A091 0000 		lds r26,matrix
 385 011c B091 0000 		lds r27,matrix+1
 386 0120 AC0F      		add r26,r28
 387 0122 BD1F      		adc r27,r29
 388 0124 E091 0000 		lds r30,matrix_prev
 389 0128 F091 0000 		lds r31,matrix_prev+1
 390 012c EC0F      		add r30,r28
 391 012e FD1F      		adc r31,r29
 392 0130 9C91      		ld r25,X
 393 0132 8081      		ld r24,Z
 394               	.LVL19:
 395 0134 9817      		cp r25,r24
 396 0136 01F0      		breq .L20
 397               		.loc 1 143 0 is_stmt 0 discriminator 1
 398 0138 0E94 0000 		call timer_read32
 399               	.LVL20:
 400 013c 6093 0000 		sts matrix_last_modified,r22
 401 0140 7093 0000 		sts matrix_last_modified+1,r23
 402 0144 8093 0000 		sts matrix_last_modified+2,r24
 403 0148 9093 0000 		sts matrix_last_modified+3,r25
 404               	.L20:
 405               	.LVL21:
 406 014c 2196      		adiw r28,1
 407               	.LVL22:
  84:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
 408               		.loc 1 84 0 is_stmt 1 discriminator 2
 409 014e C830      		cpi r28,8
 410 0150 D105      		cpc r29,__zero_reg__
 411 0152 01F0      		breq .+2
 412 0154 00C0      		rjmp .L10
 413               	.LBE102:
 144:matrix.c      ****     }
 145:matrix.c      ****     // power off
 146:matrix.c      ****     if (KEY_POWER_STATE() &&
 147:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 414               		.loc 1 147 0 discriminator 1
 415 0156 8091 0000 		lds r24,USB_DeviceState
 146:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 416               		.loc 1 146 0 discriminator 1
 417 015a 8530      		cpi r24,lo8(5)
 418 015c 01F0      		breq .L22
 148:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 419               		.loc 1 148 0
 420 015e 8091 0000 		lds r24,USB_DeviceState
 147:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 421               		.loc 1 147 0
 422 0162 8111      		cpse r24,__zero_reg__
 423 0164 00C0      		rjmp .L23
 424               	.L22:
 149:matrix.c      ****             timer_elapsed32(matrix_last_modified) > MATRIX_POWER_SAVE) {
 425               		.loc 1 149 0
 426 0166 6091 0000 		lds r22,matrix_last_modified
 427 016a 7091 0000 		lds r23,matrix_last_modified+1
 428 016e 8091 0000 		lds r24,matrix_last_modified+2
 429 0172 9091 0000 		lds r25,matrix_last_modified+3
 430 0176 0E94 0000 		call timer_elapsed32
 431               	.LVL23:
 148:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 432               		.loc 1 148 0
 433 017a 6131      		cpi r22,17
 434 017c 7742      		sbci r23,39
 435 017e 8105      		cpc r24,__zero_reg__
 436 0180 9105      		cpc r25,__zero_reg__
 437 0182 00F0      		brlo .L23
 150:matrix.c      ****         KEY_POWER_OFF();
 151:matrix.c      ****         suspend_power_down();
 438               		.loc 1 151 0
 439 0184 0E94 0000 		call suspend_power_down
 440               	.LVL24:
 441               	.L23:
 152:matrix.c      ****     }
 153:matrix.c      ****     return 1;
 154:matrix.c      **** }
 442               		.loc 1 154 0
 443 0188 81E0      		ldi r24,lo8(1)
 444               	/* epilogue start */
 445 018a DF91      		pop r29
 446 018c CF91      		pop r28
 447               	.LVL25:
 448 018e 1F91      		pop r17
 449 0190 0F91      		pop r16
 450 0192 0895      		ret
 451               		.cfi_endproc
 452               	.LFE118:
 454               		.section	.text.matrix_is_modified,"ax",@progbits
 455               	.global	matrix_is_modified
 457               	matrix_is_modified:
 458               	.LFB119:
 155:matrix.c      **** 
 156:matrix.c      **** bool matrix_is_modified(void)
 157:matrix.c      **** {
 459               		.loc 1 157 0
 460               		.cfi_startproc
 461               	/* prologue: function */
 462               	/* frame size = 0 */
 463               	/* stack size = 0 */
 464               	.L__stack_usage = 0
 465               	.LVL26:
 466               	.LBB103:
 158:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 159:matrix.c      ****         if (matrix[i] != matrix_prev[i])
 467               		.loc 1 159 0
 468 0000 E091 0000 		lds r30,matrix
 469 0004 F091 0000 		lds r31,matrix+1
 470 0008 A091 0000 		lds r26,matrix_prev
 471 000c B091 0000 		lds r27,matrix_prev+1
 472 0010 CF01      		movw r24,r30
 473 0012 0896      		adiw r24,8
 474               	.LVL27:
 475               	.L41:
 476 0014 3191      		ld r19,Z+
 477               	.LVL28:
 478 0016 2D91      		ld r18,X+
 479 0018 3213      		cpse r19,r18
 480 001a 00C0      		rjmp .L42
 481               	.LVL29:
 158:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 482               		.loc 1 158 0 discriminator 2
 483 001c E817      		cp r30,r24
 484 001e F907      		cpc r31,r25
 485 0020 01F4      		brne .L41
 486               	.LBE103:
 160:matrix.c      ****             return true;
 161:matrix.c      ****     }
 162:matrix.c      ****     return false;
 487               		.loc 1 162 0
 488 0022 80E0      		ldi r24,0
 489               	.LBB104:
 490 0024 0895      		ret
 491               	.LVL30:
 492               	.L42:
 160:matrix.c      ****             return true;
 493               		.loc 1 160 0
 494 0026 81E0      		ldi r24,lo8(1)
 495               	.LBE104:
 163:matrix.c      **** }
 496               		.loc 1 163 0
 497 0028 0895      		ret
 498               		.cfi_endproc
 499               	.LFE119:
 501               		.section	.text.matrix_is_on,"ax",@progbits
 502               	.global	matrix_is_on
 504               	matrix_is_on:
 505               	.LFB121:
 164:matrix.c      **** 
 165:matrix.c      **** inline
 166:matrix.c      **** bool matrix_has_ghost(void)
 167:matrix.c      **** {
 168:matrix.c      ****     return false;
 169:matrix.c      **** }
 170:matrix.c      **** 
 171:matrix.c      **** inline
 172:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 173:matrix.c      **** {
 506               		.loc 1 173 0
 507               		.cfi_startproc
 508               	.LVL31:
 509               	/* prologue: function */
 510               	/* frame size = 0 */
 511               	/* stack size = 0 */
 512               	.L__stack_usage = 0
 174:matrix.c      ****     return (matrix[row] & (1<<col));
 513               		.loc 1 174 0
 514 0000 2091 0000 		lds r18,matrix
 515 0004 3091 0000 		lds r19,matrix+1
 516 0008 F901      		movw r30,r18
 517 000a E80F      		add r30,r24
 518 000c F11D      		adc r31,__zero_reg__
 519 000e 2081      		ld r18,Z
 520 0010 822F      		mov r24,r18
 521               	.LVL32:
 522 0012 90E0      		ldi r25,0
 523 0014 21E0      		ldi r18,lo8(1)
 524 0016 30E0      		ldi r19,0
 525 0018 00C0      		rjmp 2f
 526               		1:
 527 001a 220F      		lsl r18
 528 001c 331F      		rol r19
 529               		2:
 530 001e 6A95      		dec r22
 531 0020 02F4      		brpl 1b
 532 0022 2823      		and r18,r24
 533 0024 3923      		and r19,r25
 534 0026 81E0      		ldi r24,lo8(1)
 535 0028 232B      		or r18,r19
 536 002a 01F4      		brne .L45
 537 002c 80E0      		ldi r24,0
 538               	.L45:
 175:matrix.c      **** }
 539               		.loc 1 175 0
 540 002e 0895      		ret
 541               		.cfi_endproc
 542               	.LFE121:
 544               		.section	.text.matrix_get_row,"ax",@progbits
 545               	.global	matrix_get_row
 547               	matrix_get_row:
 548               	.LFB122:
 176:matrix.c      **** 
 177:matrix.c      **** inline
 178:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 179:matrix.c      **** {
 549               		.loc 1 179 0
 550               		.cfi_startproc
 551               	.LVL33:
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 180:matrix.c      ****     return matrix[row];
 556               		.loc 1 180 0
 557 0000 2091 0000 		lds r18,matrix
 558 0004 3091 0000 		lds r19,matrix+1
 559 0008 F901      		movw r30,r18
 560 000a E80F      		add r30,r24
 561 000c F11D      		adc r31,__zero_reg__
 181:matrix.c      **** }
 562               		.loc 1 181 0
 563 000e 8081      		ld r24,Z
 564               	.LVL34:
 565 0010 0895      		ret
 566               		.cfi_endproc
 567               	.LFE122:
 569               		.section	.text.matrix_print,"ax",@progbits
 570               	.global	matrix_print
 572               	matrix_print:
 573               	.LFB123:
 182:matrix.c      **** 
 183:matrix.c      **** void matrix_print(void)
 184:matrix.c      **** {
 574               		.loc 1 184 0
 575               		.cfi_startproc
 576 0000 0F93      		push r16
 577               	.LCFI4:
 578               		.cfi_def_cfa_offset 3
 579               		.cfi_offset 16, -2
 580 0002 1F93      		push r17
 581               	.LCFI5:
 582               		.cfi_def_cfa_offset 4
 583               		.cfi_offset 17, -3
 584 0004 CF93      		push r28
 585               	.LCFI6:
 586               		.cfi_def_cfa_offset 5
 587               		.cfi_offset 28, -4
 588 0006 DF93      		push r29
 589               	.LCFI7:
 590               		.cfi_def_cfa_offset 6
 591               		.cfi_offset 29, -5
 592               	/* prologue: function */
 593               	/* frame size = 0 */
 594               	/* stack size = 4 */
 595               	.L__stack_usage = 4
 185:matrix.c      ****     print("\nr/c 01234567\n");
 596               		.loc 1 185 0
 597 0008 80E0      		ldi r24,lo8(__c.4588)
 598 000a 90E0      		ldi r25,hi8(__c.4588)
 599 000c 0E94 0000 		call xputs
 600               	.LVL35:
 601 0010 C0E0      		ldi r28,0
 602 0012 D0E0      		ldi r29,0
 603               	.LBB105:
 186:matrix.c      ****     for (uint8_t row = 0; row < matrix_rows(); row++) {
 187:matrix.c      ****         xprintf("%02X: %08b\n", row, bitrev(matrix_get_row(row)));
 604               		.loc 1 187 0
 605 0014 00E0      		ldi r16,lo8(__c.4591)
 606 0016 10E0      		ldi r17,hi8(__c.4591)
 607               	.LVL36:
 608               	.L48:
 609               	.LBB106:
 610               	.LBB107:
 180:matrix.c      **** }
 611               		.loc 1 180 0
 612 0018 E091 0000 		lds r30,matrix
 613 001c F091 0000 		lds r31,matrix+1
 614 0020 EC0F      		add r30,r28
 615 0022 FD1F      		adc r31,r29
 616               	.LBE107:
 617               	.LBE106:
 618               		.loc 1 187 0
 619 0024 8081      		ld r24,Z
 620 0026 0E94 0000 		call bitrev
 621               	.LVL37:
 622 002a 1F92      		push __zero_reg__
 623               	.LCFI8:
 624               		.cfi_def_cfa_offset 7
 625 002c 8F93      		push r24
 626               	.LCFI9:
 627               		.cfi_def_cfa_offset 8
 628 002e DF93      		push r29
 629               	.LCFI10:
 630               		.cfi_def_cfa_offset 9
 631 0030 CF93      		push r28
 632               	.LCFI11:
 633               		.cfi_def_cfa_offset 10
 634 0032 1F93      		push r17
 635               	.LCFI12:
 636               		.cfi_def_cfa_offset 11
 637 0034 0F93      		push r16
 638               	.LCFI13:
 639               		.cfi_def_cfa_offset 12
 640 0036 0E94 0000 		call __xprintf
 641               	.LVL38:
 642 003a 2196      		adiw r28,1
 643               	.LVL39:
 186:matrix.c      ****     for (uint8_t row = 0; row < matrix_rows(); row++) {
 644               		.loc 1 186 0
 645 003c 0F90      		pop __tmp_reg__
 646 003e 0F90      		pop __tmp_reg__
 647 0040 0F90      		pop __tmp_reg__
 648 0042 0F90      		pop __tmp_reg__
 649 0044 0F90      		pop __tmp_reg__
 650 0046 0F90      		pop __tmp_reg__
 651               	.LCFI14:
 652               		.cfi_def_cfa_offset 6
 653 0048 C830      		cpi r28,8
 654 004a D105      		cpc r29,__zero_reg__
 655 004c 01F4      		brne .L48
 656               	/* epilogue start */
 657               	.LBE105:
 188:matrix.c      ****     }
 189:matrix.c      **** }
 658               		.loc 1 189 0
 659 004e DF91      		pop r29
 660 0050 CF91      		pop r28
 661               	.LVL40:
 662 0052 1F91      		pop r17
 663 0054 0F91      		pop r16
 664 0056 0895      		ret
 665               		.cfi_endproc
 666               	.LFE123:
 668               		.section	.text.matrix_power_up,"ax",@progbits
 669               	.global	matrix_power_up
 671               	matrix_power_up:
 672               	.LFB124:
 190:matrix.c      **** 
 191:matrix.c      **** void matrix_power_up(void) {
 673               		.loc 1 191 0
 674               		.cfi_startproc
 675               	/* prologue: function */
 676               	/* frame size = 0 */
 677               	/* stack size = 0 */
 678               	.L__stack_usage = 0
 679 0000 0895      		ret
 680               		.cfi_endproc
 681               	.LFE124:
 683               		.section	.text.matrix_power_down,"ax",@progbits
 684               	.global	matrix_power_down
 686               	matrix_power_down:
 687               	.LFB125:
 192:matrix.c      ****     KEY_POWER_ON();
 193:matrix.c      **** }
 194:matrix.c      **** void matrix_power_down(void) {
 688               		.loc 1 194 0
 689               		.cfi_startproc
 690               	/* prologue: function */
 691               	/* frame size = 0 */
 692               	/* stack size = 0 */
 693               	.L__stack_usage = 0
 694 0000 0895      		ret
 695               		.cfi_endproc
 696               	.LFE125:
 698               		.section	.progmem.data.__c.4591,"a",@progbits
 701               	__c.4591:
 702 0000 2530 3258 		.string	"%02X: %08b\n"
 702      3A20 2530 
 702      3862 0A00 
 703               		.section	.progmem.data.__c.4588,"a",@progbits
 706               	__c.4588:
 707 0000 0A72 2F63 		.string	"\nr/c 01234567\n"
 707      2030 3132 
 707      3334 3536 
 707      370A 00
 708               		.section	.bss._matrix1,"aw",@nobits
 711               	_matrix1:
 712 0000 0000 0000 		.zero	8
 712      0000 0000 
 713               		.section	.bss._matrix0,"aw",@nobits
 716               	_matrix0:
 717 0000 0000 0000 		.zero	8
 717      0000 0000 
 718               		.section	.bss.matrix_prev,"aw",@nobits
 721               	matrix_prev:
 722 0000 0000      		.zero	2
 723               		.section	.bss.matrix,"aw",@nobits
 726               	matrix:
 727 0000 0000      		.zero	2
 728               		.section	.bss.matrix_last_modified,"aw",@nobits
 731               	matrix_last_modified:
 732 0000 0000 0000 		.zero	4
 733               		.text
 734               	.Letext0:
 735               		.file 4 "/usr/lib/avr/include/stdint.h"
 736               		.file 5 "../../tmk_core/common/matrix.h"
 737               		.file 6 "../../tmk_core/common/timer.h"
 738               		.file 7 "../../tmk_core/common/suspend.h"
 739               		.file 8 "../../tmk_core/common/util.h"
 740               		.file 9 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../Device.h"
 741               		.file 10 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 742               		.file 11 "../../tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccxkKTAE.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccxkKTAE.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccxkKTAE.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccxkKTAE.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccxkKTAE.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccxkKTAE.s:13     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccxkKTAE.s:31     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccxkKTAE.s:48     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccxkKTAE.s:716    .bss._matrix0:0000000000000000 _matrix0
     /tmp/ccxkKTAE.s:711    .bss._matrix1:0000000000000000 _matrix1
     /tmp/ccxkKTAE.s:726    .bss.matrix:0000000000000000 matrix
     /tmp/ccxkKTAE.s:721    .bss.matrix_prev:0000000000000000 matrix_prev
     /tmp/ccxkKTAE.s:131    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccxkKTAE.s:731    .bss.matrix_last_modified:0000000000000000 matrix_last_modified
     /tmp/ccxkKTAE.s:457    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccxkKTAE.s:504    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccxkKTAE.s:547    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccxkKTAE.s:572    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccxkKTAE.s:706    .progmem.data.__c.4588:0000000000000000 __c.4588
     /tmp/ccxkKTAE.s:701    .progmem.data.__c.4591:0000000000000000 __c.4591
     /tmp/ccxkKTAE.s:671    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccxkKTAE.s:686    .text.matrix_power_down:0000000000000000 matrix_power_down

UNDEFINED SYMBOLS
timer_read32
USB_DeviceState
timer_elapsed32
suspend_power_down
xputs
bitrev
__xprintf
__do_clear_bss
